<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css"/>
    <title>homework16</title>
</head>
<body>
<header>
    <div class="welcomeText"><p>Welcome text for my new generation of homeworks</p>
    </div>
</header>
<main>
    <div class="newInfo">
        <p class="infoJS">
            async- ставит выполнение файла js в конец,
            defer- если несколько js файлов, ставит их в конец и выпоняет по очереди написания
        </p>
        <div cls="aboutConstructors">

            Один из подвидов функции- это функция КОНСТРУКТОР
            позволяет создавть методы в обьектах, автоматизируя набор кода

            Имя функции-конструктора должно начинаться с большой буквы.
            Функция-конструктор должна выполняться только с помощью оператора "new"

            C БОЛЬШОЙ БУКВЫ МЫ НАЗЫВАЕМ ТОЛЬКО ФУНКЦИИ-КОНСТРУКТОРЫ
            также могут быть написаны классы и реакт-компоненты,
            с маленькой буквы тоже будет работать, но так не принято, лучше так не писать

            При создании используются либо function expression либо declaration, так как стрелочные функции тут не работают
            По той причине, что тут также используется this

            Когда мы создаем обьект через конструктор, будет храниться принадлежность к определенному конструктору, тот,
            который создал

            функция конструктор это фабрика по созданию елементов- массивов, обьектов, классов, работа с DOM

            для того, чтобы руками не прописывать однотипные обьеты, мы можем с помощью конструкторов создать некую "фабрику"
            что ускоряет и автоматизирует процесс, более быстрое создание обьектов, агрегатор для создания обьектов

            Как проверить, является ли конкретный обьект екземпляром какого-либо конструктора?

            Для этого существует оператор instanceof
            пишется слева от переменной и указывается класс
            yulia instanceof User
            возвращает true/false
            Можно также проверить является ли массивом, или обьектом
            Проверяем на принадлежность к чему-то
            Все, кроме примитивов, являетя обьектами, функции, обьекты, массивы

            Название конструктора- всегда с большой буквы, всегда сущность- User, Date, Shop, Facility....
            И с помощью конструктора создаем екземпляры


            JS DOC- это хороший способ записать в комментарий перед сложным обьектом, массивом, функцией, какие параметры
            /**  и enter
            @param- это параметры
            в {}- пишем тип обьекта- tring, nu,ber, object, constructor....
            Это способ типизации, унификации записи и данных
            особенно если набирается чистый JavaScript, не  TypeScript
            позволяет в будущем опустить намного меньше ошибок
            желательны, из чего состоит и тип объекта
            Это один из видов комментариев, никак не влияет на написание кода,
            плюс записав перед сложным обьетом такое, то потом еще будет помогать автокомплит

            обьекты и масиивы будут равны, только когда они ссылаются один на другой
            const arr1=[];
            const arr2=[];
            arr1===arr2 false
            const arr3=arr1;
            arr3==arr1 true

            JavaScript является языком с динамической типизацией, вы можете спокойно объявлять переменные, функции,
            объекты и что угодно, не объявляя тип.


            У функции конструктора можно созавать методы, в них вкладывать обьекты, массивы, функции, методы и т.д.

            типизация помогает избежать ошибок при наборе кода

            Сам по себе конструктор позволяет создавать методы для быстрого создания обьектов


        </div>
        <div class="about Descriptors. Getters/Setters">

            about Descriptors. Getters/Setters

            Существует два встроенных обьекта- обьект map и обьект set

            В обьектах название свойств  это всегда строка
            Даже если я запишу числом, оно будет приведено к строке
            Также из-за этого нельзя никаких сложных данных хранить в свойстве
            Для решения этой проблеммы был создан обьект map
            const obj=new Map();
            Для того, чтобы установить свойство, используется метод .set
            obj.set(55,'number');
            Для того, чтобы получить значение, используется метод .get
            obj.get(55)
            В обычном обьекте в качестве ключа не возможно хранить какие-то сложные данные, все только строка
            Если в качестве свойства передать другой обьект, то запишется ['Object object']

            Если я хочу использовать в качестве свойства какие-то сложные данные, типа обьекта, для этого используется
            new Map()
            map.delete()- чтобы удалить какой-то ключ
            map.has()- проверить на наличие чего-либо
            Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

            Методы и свойства:

            new Map() – создаёт коллекцию.
            map.set(key, value) – записывает по ключу key значение value.
            map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
            map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
            map.delete(key) – удаляет элемент по ключу key.
            map.clear() – очищает коллекцию от всех элементов.
            map.size – возвращает текущее количество элементов.

            map.keys- возвращает псевдомассив с ключами
            map.values-
            map.entries-


                                            ОБЬЕКТ SET
            Он подобен массиву, но в нем не хранятся дубликаты
            создается через конструктор new SET
            arr.add()- чтобы запушить что-то, будет перезаписывать повторяющиеся значения
            Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться
            только один раз.

            Его основные методы это:

            new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив),
            то копирует его значения в новый Set.
            set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
            set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
            set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
            set.clear() – удаляет все имеющиеся значения.
            set.size – возвращает количество элементов в множестве.
            Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит,
            за счёт этого как раз и получается, что каждое значение появляется один раз.

            Например, мы ожидаем посетителей, и нам необходимо составить их список. Но повторные визиты не должны приводить
            к дубликатам. Каждый посетитель должен появиться в списке только один раз.

            Множество Set – как раз то, что нужно для этого
            Хорошо подходит для простых данных, можем потом перегнать все снова в массив, скопировав через ...

        </div>
    <div class="GettersSetters">
        Это способы взаимодействия с данными обьекта, которые работают как функции, а выглядят как свойства
        Способ декорировать, аргументов не принимает, работает сходно метода get(){}
        Также существуют сеттеры set(){}
        Он может принимать аргументы
        Когда пытаемся получить совйство, то вызывается геттер, когда хочем перезаписать , то вызывается сеттер

    </div>
        <div class="descriptors">
            ABOUT DESCRIPTORS
            Дескрипторы- это свойства свойств обьекта
            Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги»).

            writable – если true, свойство можно изменить, иначе оно только для чтения.
            enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
            configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
            Чтобы изменить флаги, мы можем использовать метод Object.defineProperty.
            У каждого свойства обьекта есть этот набор дескрипторов, кторые могу устанавливать
            Таким образом, можно "заморозить" какое-то свойство в обьекте и от него не избавиться
            ПРи необходимости, можно изменять значения дескрипторов true/false
            DefineProperty по умолчанию false, сли я уже создаю так свойство, то я его автоматически замораживаю

        </div>
        Метод Object.defineProperties
        Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.

        Его синтаксис:
        Object.defineProperties(obj, {
        prop1: descriptor1,
        prop2: descriptor2
        // ...
        });
        Object.getOwnPropertyDescriptors
        Чтобы получить все дескрипторы свойств сразу, можно воспользоваться методом Object.getOwnPropertyDescriptors(obj).
        Глобальное запечатывание объекта
        Дескрипторы свойств работают на уровне конкретных свойств.

        Но ещё есть методы, которые ограничивают доступ ко всему объекту:

        Object.preventExtensions(obj)
        Запрещает добавлять новые свойства в объект.
        Object.seal(obj)
        Запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих свойств.
        Object.freeze(obj)
        Запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable: false для всех существующих свойств.
        А также есть методы для их проверки:

        Object.isExtensible(obj)
        Возвращает false, если добавление свойств запрещено, иначе true.
        Object.isSealed(obj)
        Возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств установлено configurable: false.
        Object.isFrozen(obj)
        Возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено configurable: false,
        writable: false.
        На практике эти методы используются редко.
    </div>
</main>
<script async src="index.js"></script>

<!--<script defer src="index.js"></script>-->

</body>
</html>