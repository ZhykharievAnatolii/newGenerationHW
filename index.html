<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css"/>
    <title>homework11AboutArrays</title>
</head>
<body>
<header>
    <div class="welcomeText"><p>Welcome text for my new generation of homeworks</p>
    </div>
</header>
<main>
  <div class="moreIfo">

        <p>Arrays INTRO</p>
      <div class="about">
        Массив- это один из видов обьектов, изначально это список,
          Вместо названия свойств в массиве использется число по номеру в списке, отсчет всегда начинается с нулевой позиции
          Автоматическая логика массива присваивает ему ключ-значение по индексу-номеру, и обращаясь к содержимому, мы обращаемся через []
            Массивы очень хорошо оптимизированы для браузера
          Когда нам нужна коллекция чего-то, то это удобно хранить в массиве, например список товаров
          Также в массиве мы можем хранить обьекты, и наоборот
          const numbers=[12,11,10,1,2,5,6,7,4,5,6,7,8];

          Массивы удобно использовать для однотипных данных, используется для отднотипных, структурных данных
          names[3]=`Yura`- добавить что-то в масссив
          names[names.length]- так можно добавлять, не цепляясь к индексу
          Для того чтобы дописать что-то к массиву, пишемназвание, через [] обращаемся  к имени и ставим метод length
          Добавлять можем что угодно, строки, числа, обьекты, массивы


          Методы для МАССИВОВ
          Метод для определения длинны массива-
          names.length

          PUSH
          Для добавления к массиву новых елементов, лучшим методом является push();
          Автоматически ставит следущим по порядку и в консоли сразу отображает количество елементов
          Метод Push принимает не ограниченное количество аргументов, все аргументы добавляются по порядку , не можум сразу сортировать
          одновременно с добавлением
            ВСЕГДА ДОБАВЛЯЕТ В КОНЕЦ МАССИВА
          Можем создавать функции , которые упрощают нам ввод однотипных данных, такого типа функции называются конструкторы

          МЕТОД unshift()- рботает точно так же как и push, но добавляет елемент в начало массива
          Эта операциия тяжелее для памяти, так как перебирает все елементы массива
            Также принимает бесконечное количество елементов

          МЕТОД для обьединения массивов .CONCAT()
          const mergedArr=names.concat(students)- пример синтаксиса
          Метод массива, который к содержимому исходного массива, добавляет по порядку следущий
          метод concat может быть вызван на любом массиве, и в аргумент мы вставляем тот массив, котрый хотим присоединить
          также через concat можно добавить строку, число

          Метод POP()- вырезает ровно один елемент-самый последний
          Метод SHIFT() -вырезает ровно один елемент-самый первый

          Метод SPLICE()- способ удалить елемент по индексу, в первый аргумент вносим индекс, во второй, по какой
        также можем вносить елементы в зависимости от их индекса

          Метод indexOf()- позволяет по названию елемента определить его индекс в массиве, если не находит ничего, то возвращает
            "-1"

        Методы для перебора массивов-
        FOR EACH ()
        это метод, в аргумент которого нужно передать функцию
        первым аргументом передается сам массив, вторым функция, и выводим перебор массива
        позволяет перебрать каждый елемент массива, без дополнительных действий после
        В первый аргумент передаем елемент, во второй можем передать индек, в третий сам массив
        Сам по себе метод возвращает undefined, нужен он для того, чтобы перебрать все елементы,
        например чтобы отрисовать список чего-то , не изменяя его
        что-то сделать с оригинальными данными
        можно сразу писать в аргумент стрелочную функцию
        Первый аргумент принимает елемент массива, второй это индекс

        ПРОСТО ПЕРЕБОР ВСЕХ

        Анонимная функция- это функция, которая не имеет имени, используется в качестве аргумента, только один раз

        Метод .MAP()-
        возвращает новый массив, видоизменяя старый, но не затрагивая его длинну
        MAP  НУЖЕН ДЛЯ ТРАНСФОРМАЦИИ
        Сам по себе метод не видоизменяет исходный массив

        ИЗМЕНЕНИЕ ДАННЫХ, ОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ return

        Array.isArray(arr) проверяет, является ли arr массивом


        МЕТОД FILTER()-
        позволяет отфильтровать елементы массива и вернуть новый массив с этими елементами
        Возвращает условие, если оно является TRUE, то будет записано в новый массив, если нет, пропускается
        Если FALSE, то будет пропущен этот елемент


        Если нужно просто перебрать- forEach
        Если трансформировать- Map
        Если отфильтровать- Filter- должен вернуть условие, true,false undefined===false


        МЕТОД .SOME()- проверяет элементы массива в соответствии с переданной функцией. Эта функция передается параметром
        метода и выполняется для каждого элемента массива. Метод возвращает true , если хотя бы для одного элемента
        массива переданная функция вернет true , в противном случае метод возвращает false

        похож по работе на filter, если хотя бы раз найдет true, то прекратит свою работу
        Находит только первый елемент, котрый соответсвует true, не продолжает свою работу

        .EVERY()- работает противоположно SOME, сразу прекращает свою работу, встречая первую ложь- false

        Может вернуть True, только если все елементы true, можно таким образом проверить все ли true


        МЕТЕОДЫ   .SOME()    И    .EVERY()   -ДЛЯ ПРОВЕРКИ TRUE / FALSE


        Массив- єто нумерованный обьект, в котором свойства расположены по порядку и не имеет названия, автоматически ставится,
        индекс, начиная с 0
        Хранить в массиве можем любые данные, упорядочивая их, обьекты, строки, числа и т.д.
        Можно хранить в массиве массивы
        чтобы добавить елемент-
        push- добавть в конец массива
        unshift- добавить в начало
        pop- вырезать в конце
        shift- вырезать в начале
        splice()- позволяет удалить с определенной позиции и добавть если необходимо
        slice()- если ничего не указать, вернет копию массива

        Самое главное преимущество массива, что данные плотно и подряд сгрупированы
        fofEach- перебирает все елементы массива не видоизменяя их
        map возвращает новый массив той же длинны, и измененный так, как мы хотим

        Для поиска елемента в массиве можно использовать filter, но разумнее и удобнее .FIND()
        синтаксис подобный filter, но вернет не массив, а сам искомый елемент
        const kill=students.find((element)=>{
        return element.name===`Kill`
        });
        чаще всего используется для поиска обьектов

        Array.isArray(arr) проверяет, является ли arr массивом.

        МЕТОД .REDUCE()-

        необходим, если нужна связь между етерациями
        вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая
        промежуточный результат между вызовами.

        Может принимать два аргумента, функцию и изначальное значение аргумента
        позволяет хранить между етерациями какое-то значение
        если в каком-то из циклов undefined, то метод ломается, вернет undefined
        Если в функцию reduce вставить условие, то не будет работать, будет undefined
        БУДЕТ работать, если не забыть вствить RETURN

        Когда мы ищем самое максимальное число, можем использовать для сравнения -Infinity
        когда ищем самое максимальное , то  +Infinity

        Если не поставить в конце значение, 0, или какое нужно, то автоматически будет отсчитывать с 1го елемента
        а накапливать все во второй
        Нужно указывать откуда мы начинаем считать

        REDUCE.RIGHT- работает абсолютно точно так же , но отсчет начинает с права на лево

        Object.entries()- метод преобразования обьекта в массив

        split()- МЕТОД строки , для того чтобы ее разбить на массив, по определенному символу

        join()- метод массива, обьединяющий строку, задаются параметры так же как и у split

        метод includes()- позволяет определить, содержит ли массив искомый элемент. В случае нахождения элемента
        метод возвращает логическое значение true, в обратном случае false.

        Sort()
        Find()
        FindIndex()














      </div>
  </div>
</main>
<script async src="index.js"></script>

<!--<script defer src="index.js"></script>-->

</body>
</html>