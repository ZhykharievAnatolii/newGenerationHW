<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css"/>
    <title>homework15</title>
</head>
<body>
<header>
    <div class="welcomeText"><p>Welcome text for my new generation of homeworks</p>
    </div>
</header>
<main>
    <div class="newInfo">
        <p class="infoJS">
            async- ставит выполнение файла js в конец,
            defer- если несколько js файлов, ставит их в конец и выпоняет по очереди написания
        </p>
        <div cls="aboutConstructors">

            Один из подвидов функции- это функция КОНСТРУКТОР
            позволяет создавть методы в обьектах, автоматизируя набор кода

            Имя функции-конструктора должно начинаться с большой буквы.
            Функция-конструктор должна выполняться только с помощью оператора "new"

            C БОЛЬШОЙ БУКВЫ МЫ НАЗЫВАЕМ ТОЛЬКО ФУНКЦИИ-КОНСТРУКТОРЫ
            также могут быть написаны классы и реакт-компоненты,
            с маленькой буквы тоже будет работать, но так не принято, лучше так не писать

            При создании используются либо function expression либо declaration, так как стрелочные функции тут не работают
            По той причине, что тут также используется this

            Когда мы создаем обьект через конструктор, будет храниться принадлежность к определенному конструктору, тот,
            который создал

            функция конструктор это фабрика по созданию елементов- массивов, обьектов, классов, работа с DOM

            для того, чтобы руками не прописывать однотипные обьеты, мы можем с помощью конструкторов создать некую "фабрику"
            что ускоряет и автоматизирует процесс, более быстрое создание обьектов, агрегатор для создания обьектов

            Как проверить, является ли конкретный обьект екземпляром какого-либо конструктора?

            Для этого существует оператор instanceof
            пишется слева от переменной и указывается класс
            yulia instanceof User
            возвращает true/false
            Можно также проверить является ли массивом, или обьектом
            Проверяем на принадлежность к чему-то
            Все, кроме примитивов, являетя обьектами, функции, обьекты, массивы

            Название конструктора- всегда с большой буквы, всегда сущность- User, Date, Shop, Facility....
            И с помощью конструктора создаем екземпляры


            JS DOC- это хороший способ записать в комментарий перед сложным обьектом, массивом, функцией, какие параметры
            /**  и enter
            @param- это параметры
            в {}- пишем тип обьекта- tring, nu,ber, object, constructor....
            Это способ типизации, унификации записи и данных
            особенно если набирается чистый JavaScript, не  TypeScript
            позволяет в будущем опустить намного меньше ошибок
            желательны, из чего состоит и тип объекта
            Это один из видов комментариев, никак не влияет на написание кода,
            плюс записав перед сложным обьетом такое, то потом еще будет помогать автокомплит

            обьекты и масиивы будут равны, только когда они ссылаются один на другой
            const arr1=[];
            const arr2=[];
            arr1===arr2 false
            const arr3=arr1;
            arr3==arr1 true

            JavaScript является языком с динамической типизацией, вы можете спокойно объявлять переменные, функции,
            объекты и что угодно, не объявляя тип.


            У функции конструктора можно созавать методы, в них вкладывать обьекты, массивы, функции, методы и т.д.

            типизация помогает избежать ошибок при наборе кода

            Сам по себе конструктор позволяет создавать методы для быстрого создания обьектов


            <div class="newMethodsObjects">
            Метод для перебора обьектов- for in
            не совсем удобно и читаемо, мы можем перевести обьект в массив и использовать методы для перебора масиива

            Существует три способа для перебора обьектов в массив

            Object.keys();--ЕСЛИ НУЖНЫ ТОЛЬКО КЛЮЧИ ОБЬЕКТА

            возвращает массив ключей обьекта
            не заходит в глубь обьектов, что лежат в массиве, вернет только свойства и все

            Object.values();- ЕСЛИ НУЖНЫ ТОЛЬКО ЗНАЧЕНИЯ

            Object.entries();- ДЛЯ ПЕРЕБОРА КАК КЛЮЧЕЙ ТАК И ЗНАЧЕНИЙ
            Возвращает массив массивов
            Будет содержать по 2 елемента,
            0-это ключ
            1й- это значение

            Object.fromEntries();- способ перебора ключей и значений возвращающий обратно обьект из массива

            Чтобы удобно перебирать обьекты существуют эти методы


            В JavaScript есть две чаще всего используемые структуры данных – это Object и Array.

            Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.
            Массивы позволяют нам собирать элементы данных в упорядоченный список.
            </div>

            <div class="Destructurization">Деструктуризация---------------------------------------------------</div>
            Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или
            объекты в несколько переменных, так как иногда они более удобны.

            «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью
            присваивания, его задача – только скопировать нужные значения в переменные.

            Позволяет из обьекта или массива вытащить какое-то свойство, и сразу определить его в переменную
            Если это простые типы данных, то выделяя их из массива в переменные с помощью деструктуризации, мы не изменяем
            сам массив
            если это обьектные данные, то изменяя их , будет мутировать оригинальный обьект

            Деструктуризация массива- это квадратные скобки , и пишемм названия переменных по тем же позициям(индексам)что нам нужны
            Если нужно пропустить , ставим запятую
            Деструктуризация работает как в определении переменных, так и в аргументах функции, как колбек так и любая другая
            Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента,
            которая затем вызывается по завершению какого-либо действия.
            Сама по себе дестб если ее использовать с другими данными, не работает
            ДЕСТРУКТУРИЗАЦИЯ РАБОТАЕТ ТОЛЬКО С МАССИВОМ

            Если делаем деструктуризацию, и все параметры задаем сразу в функции, обязательно последним аргументом мы должны приравнять все к массиву,
            иначе работаеть не будет
            в крайнем случае, при вызове поставить пустой массив

            Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

            ДЕСТРУКТУРИЗАЦИЯ ОБЬЕКТОВ

            такжде пишем переменную, название свойства, должно соответсвтовать свойству в массиве, название свойства в {}
            =нужный массив

            Оператор «spread»
            Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один
            параметр, который получит «всё остальное», при помощи оператора "..." («spread», троеточие):
            Используется если что-то нужно деструктурировать, а остаток использовать как массив, используется этот оператор
            Также можем дописывать переменные через ={};
            Позиция свойства не важна, так как переменная определяется по имени


            ПРи копировании через ... не передается по ссылке, поэтому, меняя новый обьект, мы не изменим старый

            Деструктуризация никогда не меняет параметры, ее делаем, чтобы что-то получить новое

            При деструктуризации можем менять название того, что хотим вынести в переменную
            const {name:bohdanName}=user;
            таким образом я вытащил свойство name, но записал его в переменную bohdanName

            КОПИРОВАНИЕ МАССИВОВ
            Через оператор spread
            const copied=[... nameOfArrayWhichCopied]

            КОПИРОВАНИЕ ОБЬЕКТОВ
            const user={name:'John'};
            const copy={...user};
            user===copy
            false

        </div>
        <div class="Dates">
            ВСТРОЕННЫЙ ОБЬЕКТ В JS--- DATES

            const date=new Date();- при таком создании, если ничего не пердать в аргумент, дата будет текущяя
            Этот обьект выводится как строка
            Если не ставить никаких аргументов, то будет текущая дата,
            если только один аргумент- время в милисекундак
            Если от 2х, то можно ставить, год , месяц,число,  время
            const myBirth=new Date(1987,11,27,17,00,00,00);
            также можно записать в стоке
            const anotherDate=new Date('1987-12-27T17:00:00');-тогда месяцы совпадают
            также есть методы для дат
            today.getFullYear();
            методы возвращают число, не строку

            Также можем получить формат даты по варианту UTC
            today.getUTCHours();
            today.getUTCMonth();

            Для того, чтобы изменить, существует метод set
            today.setHours(5);
            today.setMonth(5);
            Просто устанавливает значение, без оглядки не то что было до этого

            Если хочу добавить, используя прошлое время, то используется сразу два метода
            today.setMinutes(today.getMinutes()+1);

            Также есть методы  .setUTC

            Date.now();- возвращает слепок миллисекунд прямо сейчас

        </div>

    </div>
</main>
<script async src="index.js"></script>

<!--<script defer src="index.js"></script>-->

</body>
</html>